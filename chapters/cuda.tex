\chapter{Algorithmus und GPU Implementierung}

\section{Einleitung}

Nachdem das theoretische und numerische Fundament gelegt wurde, soll nun auf die Implementierung  eingegangen werden.
Dieser Abschnitt bezieht sich auf den grundlegenden Algorithmus, welcher im Rahmen der Master-Arbeit basierend auf einer bestehenden
Version von [] übernommen, erweitert und optimiert wurde.
Die zusätzlich eingeführten  Immersed Boundary Methoden werden ausführlich in Abschnitt () behandelt.

Für die Parallelisierung  des Codes wurde die nvidia/interface CUDA-API verwendet mit welcher es möglich ist einen Großteil der Berechnungen
auf die Grafikkarten auszulagern.

-HARDWARE - karten varianten c1060 und tesla k20m , datasheet im anhang
-beschreibung GPGPU


\section{GPGPU mit CUDA}

Bei CUDA \footnote{Computing Uniform Device Architecture} handelt es sich um eine von NVIDIA entwickelte Architektur welche die
Entwicklung von GPGPU\footnote{General Purpose Computation on Graphics Processing Unit - Allg.
Bezeichung für Allzweck-Berechnungen auf Grafikprozessoren}-Anwendungen erheblich vereinfacht.
Dies wird im wesentlichen durch die Abstraktion der Hardwarearchitektur auf die CUDA-API? erreicht.
Es handelt es sich dabei um eine Sprachrweiterung

- dabei handelt es sich mu eine c/c++ erweiterrte sprache aber auch bindings in python etc



 eine höhere Programmiersprache erreicht.

- vereinfachung  der architektur abstraktion software layer
- erzeugung mit nvcc

-toolchain

-speicher vs hardware architektur



-In Abbildung () ist exemplarisch das Speicherlayout der cuda karte dargstellt .
-Hierbei sei angemerkt das dies in keiner weise dem hardware layou entspricht aber als model
-für verständnis der algoritmhus am besten
-z.b. ist der local memory auf der karte im global memory speicherbereich

- lese paper / präsi zur optimierung
- geschwindigkeiten
- shared vs global etc

\begin{figure}[!bp]
  \centering
  \includegraphics[width=0.8\textwidth]{gfx/cuda/gpu.png}\label{fig:gpu_arch}
  \caption{Speicherlayout einer Nvidia-GPU}
\end{figure}

-bild
-speicher bereiche
-grid layout function call
-threadidx etc

\section{Algorithmus}
-oder so ?
-erläuterung  implementierung
-speicherverwaltung

\section{Optimierung}
- coalesceded
- bank conflicts?
- teilvolumen nicht rechnen

\section{Validierung}
- beispiel rayleigh benard system
- masa
- vgl o2 vs o4 masa cube
- bifurcation


\newpage

