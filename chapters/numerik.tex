\chapter{Numerical Methods}

\section{Introduction}

This chapter focuses on the methods that are used for the numerical computations in this thesis.
In order to compute the temporal evolvement of a fluid system from its initial state, it is necessary to discretize
the equations of motion by using different numerical schemes.\\
For this purpose various discretization approaches, for example finite-element and finite-volume methods, exists.
Here we will introduce the method of finite-difference stencils for the spatial and a third order Runge-Kutta method for the discretization in time.
Furthermore we will introduce the method of artificial compressibility, which can be used to avoid the numerical expensive solution of a poisson equation.
The choice of these methods in combination with the usage of cartesian grids is in particular time saving when performing computations on the gpu, as we
will see in chapter \ref{chapter:cuda}.

\section{Finite Differencing Schemes}

We start with a brief introduction of finite difference methods.
The interested reader is referred to \citep{ferziger99} for a more general overview, from where this section is adapted.
The partial differential equations we want to solve in this thesis are of the form

\begin{align}
    \label{numerik:pde_allg}
    \pdn[\Phi]{t} = A \pdn[^2\Phi]{x^2}  + B \pdn[^2\Phi]{x^2}     + C(\vec{r}, \vec{u}, t) +  \vec{u}\left(\pdn[^2\Phi]{x^2} +  \pdn[^2\Phi]{x^2} + \pdn[\Phi]{x}\right) = \mathcal{L}
\end{align}

for a variable $\Phi(\vec{r}, t)\in\mathbb{R}$.
The numerical integration can be divided into two steps, the calculation of the differential operator $\mathcal{L}$, which we want to discuss in this
section and secondly the integration in time.
The exact calculation of the spatial derivatives in $\mathcal{L}$ is numerically not possible.\\
Due to the limited storage capacity and computation time of computers,
it is necessary to discretize the domain, on which the PDE should be solved and find a adequate approximation of these operators.
Here we will fall back to the  one-dimensional case, the implementation for three dimensions will be discussed in chapter \ref{chapter:cuda}.\\

Let $\Omega = \{x \in \mathbb{R} \;|\; 0 \leq x \leq L\}$ be the domain on which we want to solve equations of the type \ref{numerik:pde_allg}.
For the discretization we divide $\Omega$ into $N$ equidistant points $x_i = \sum_i \Delta x_i$, with the position index ${i\in\{[0, N-1]|i\in\mathbb{N}\}}$
and $\Delta x_i = x_{i+1} - x_i = L/(N-1)$.
\footnote{EVTL?}
We assume that $\Phi$ is a  continuous differentiable function.
Local to a grid point $x_i$ and $\Phi$ can than be expressed with a Taylor series [CITE].

\begin{align}
    \label{num:taylor}
    \Phi(x) = \sum_{n=0}^{\infty} \pdn[^n\Phi(x_i)]{x^n} \frac{(x - x_i)^n}{n!}
\end{align}

By evaluating the Taylor expansion at different points, we obtain expressions for the first derivative. For example
a combined evaluation at the points $x_{i+1}$, $x_{i-1}$ leads to the expression

\begin{align}
    \label{num:cds}
    \left.\left(\pdn[\Phi]{x}\right)\right|_{i} = \frac{\Phi_{i+1} - \Phi_{i-1}}{x_{i+1} - x_{i-1}}
     - \frac{(x_{i+1} - x_i)^2 - (x_i - x_{i-1})^2}{2 (x_{i+1} - x_{i-1})}\left(\pdn[^2\Phi]{x^2}\right)_i + \mathcal{O}(\Delta x^3)
\end{align}

For a constant grid size, that is $\Delta x := \Delta x_i = \text{const.}$, the second order term in equation \ref{num:cds} vanishes.
By neglecting all terms of higher order, we obtain a approximation for $\partial_x \Phi$ of second order.
This is the so-called central-difference (CDS) scheme. A single point evaluation of \ref{num:taylor} at $x_{i+1}$ and $x_{i-1}$, results in the forward- (FDS) and
backward- (BDS) scheme of first order. A comparison of the FD-schemes is given in table \ref{num:df_table}


\bgroup\large
\begin{table}[!tbp]
\centering
\def\arraystretch{2.2}%
\begin{tabular}{c c c c c}\toprule
Scheme-Name & Stencil & Truncation Error & Evaluation at\\[0.5ex]
\midrule
Forward  (FDS) & $\left(\pdn[\Phi]{x}\right)_i =  \frac{f_{i+1} - f{i}}   {\Delta x}$ & $\mathcal{O}(\Delta x)$  &$x_{i+1}$\\
Backward (BDS) & $\left(\pdn[\Phi]{x}\right)_i = \frac{f_{i}    - f_{i-1}}{\Delta x}$  &$ \mathcal{O}(\Delta x)$ & $x_{i-1}$\\\
Central  (CDS) & $\left(\pdn[\Phi]{x}\right)_i = \frac{f_{i+1}  - f_{i-1}}{2\Delta x}$ &$ \mathcal{O}(\Delta x^3)$& $x_{i+1}$ \& $x_{i-1}$\\
\\
\bottomrule
\label{num:df_table}
\end{tabular}
\caption{Different FD-Schemes}
\end{table}
\egroup

\begin{figure}[!btp]
  \centering
    \resizebox{0.9\textwidth}{!}{
   \import{gfx/numerik/}{finite_differenzen.pdf_tex}
  }
  \caption{Approximation of the function $\Phi$ by different finite difference schemes.}
  \label{num:fd_image}
\end{figure}

The numerical error which is made by neglecting the higher order terms, is in general referred to as the truncation error of a FD-scheme.
It should be noted that the number of grid points used for the approximation, does significantly affect the resulting error.\\
Finally figure \ref{num:fd_image} shows a visual comparison for the three different stencils.
This example once again illustrates that when approximating a function, which contains higher order terms i.e. at a local maximum,
the  CDS-scheme gives better results.\\
For the computation of the second derivative, one approach is to evaluate equation \ref{num:taylor} halfway between two points at the positions $x_{i\pm\frac{1}{2}}$

\begin{align}
    \left.\left(\pdn[^2\Phi]{x^2}\right)\right|_{x_i} =
     \frac{\left.\left(\pdn[\Phi]{x}\right)\right|_{i+\frac{1}{2}}-
     \left.\left(\pdn[\Phi]{x}\right)\right|_{i-\frac{1}{2}}}
    {\frac{1}{2}(x_{i+1} - x_{i-1})} + \mathcal{O}(\Delta ^2)  \approx
    \frac{\Phi_{i+1} - 2\Phi_i + \Phi_{i-1}}{\Delta x^2}
\end{align}

For the approximation of the first derivatives, it is necessary to use the FDS-scheme at $x_{i+1/2}$ and the BDS-scheme at $x_{i-1/2}$ to obtain
a second order accuracy.\\
So far we introduced methods up to an accuracy of second order. The fourth order methods which are used in this thesis are given by

\begin{align}
    \left(\pdn[\Phi]{x}\right)_i &\approx \frac{-\Phi_{i+2} + 8\Phi_{i+1} - 8\Phi_{i-1} + \Phi_{i-2}}{12\Delta x} \\
    \left(\pdn[^2\Phi]{x^2}\right)_i &\approx \frac{-\Phi_{i+2} + 16\Phi_{i+1} -30\Phi_i + 16\Phi_{i-1} - \Phi_{i-2}}{12\Delta x^2} \\
\end{align}

The derivation of these equations can be performed in analogy to the second order schemes, but by using a five-point
stencil. The interested reader is referred to \citep{Fornberg1988}.

\newpage

\section{Runge-Kutta Method}







For the temporal discretization the third-order low-storage Runge-Kutta scheme is used, first introduced by [Williamson].
Third order methods are often used for cfd-simulations, since they tend to stabilice numerical oscilltions in advection terms[].\\
We begin with considering the inital value problem.

\begin{align}
    \left(\pdn[f]{t}\right) = F(t, f(t)) ; f(t_0) = f_0
\end{align}

This differtial equation can be solved by integration, with the exact solution
\begin{align}
    f(t) = f(0) + \int_{t_n}^{t}F(t, f(t))dt
\end{align}
In the next step the integral is splitted into piecewiese integration, with time intervalls $[t^n, t^{n+1}]$.
\begin{align}
    f(t^{n+1}) = f(t) + \int_{t_n}^{t_{n+1}}F(t, f(t))dt
\end{align}

When using runge kutta methods, the function F(t, f(t)) is evaluated at $s$ different timesteps $\tau_i = t^n + \Delta t \alpha_i$,
furthermore for each $\tau$ a different weight parameter $b_i$ is used.V
The numerical computation of the integral is than given by [].

\begin{align}
    f(t^{n+1}) = f(t) + \Delta t \sum_{i=1}^s b_i k_i, k_i = F(t^n + \Delta t c_s, f^n + \Delta t \sum_{i=1}^{s-1}a_{si}k_i)
\end{align}

With the definition of $\sum c_i$, the runge kutta scheme of third order is festgelegt by the butcher tablau
By using taylor expansion and coefficient comparison, it can be shown that this  method converges at third order.


- In order to use as  so wenig speicher wie möglich williamson scheme
- 2 speicherstack für jede variable

\begin{align}
    S_1 = \delta t F(f^n ; f^(1) = f^n + \frac{S_1}{3}) \\
    S_1 = \delta t F(f^n ; f^(1) = f^n + \frac{S_1}{3}) \\
    S_1 = \delta t F(f^n ; f^(1) = f^n + \frac{S_1}{3}) \\
\end{align}


-stabilitätsregion

\section{Numerical Stability}\mbox{}\\

-beispiel erste abl dann zweit
-stabilität konstistenz - konvergenz etc
-verfahren höherer ordnung
-peclet zahl
-upwind schema



\newpage

\section{Artificial Kompressibility}
bewegungsgleichungen
druckterm diskussion
exkurs laplace gleichung
beispiel rayleigh benard diskretisierung

\section{Numerical Stability}\mbox{}\\
-introduction
-peclet number
-


\paragraph{Advection Term}\mbox{}\\
bla


